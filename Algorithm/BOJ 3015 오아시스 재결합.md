# BOJ 3015 오아시스 재결합

```c++
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#include <stack>
#include <deque>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>

using namespace std;
#define INF 1234567890

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<pair<int, int>> stk;
	long long cnt = 0;
	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		while (!stk.empty() && stk.back().first < x) {
			cnt += stk.back().second;
			stk.pop_back();
		}
		if (!stk.empty() && stk.back().first > x)
		{
			cnt++;
			stk.push_back({x, 1});
		}
		else if (!stk.empty() && stk.back().first == x) {
			cnt += stk.back().second;
			if (stk.size() >= 2)  cnt++;
			stk.back().second++;
		}
		else if (stk.empty()) {
			stk.push_back({ x,1 });
		}
	}
	cout << cnt;


	return 0;
}


```





---

# 오아시스 재결합 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| --------- | ----------- | ---- | ---- | --------- | --------- |
| 1 초      | 256 MB      | 4079 | 934  | 628       | 22.795%   |

## 문제

오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.

이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.

두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.

줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)

둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231 나노미터 보다 작다.

사람들이 서 있는 순서대로 입력이 주어진다.

## 출력

서로 볼 수 있는 쌍의 수를 출력한다.

## 예제 입력 1

```
7
2
4
1
2
2
5
1
```

## 예제 출력 1

```
10
```



## 출처

[Olympiad ](https://www.acmicpc.net/category/2)> [Croatian Highschool Competitions in Informatics ](https://www.acmicpc.net/category/25)> [2007 ](https://www.acmicpc.net/category/31)> [Croatian Olympiad in Informatics 2007](https://www.acmicpc.net/category/detail/106) 1번

- 문제를 번역한 사람: [baekjoon](https://www.acmicpc.net/user/baekjoon)